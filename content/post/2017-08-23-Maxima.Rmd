---
title: "Symbolic Computation in R, alternative to rSympy"
author: "Simona Jokubauskaite"
date: 2017-08-23T21:13:14-05:00
categories: ["R+Maxima"]
tags: ["R", "wxMaxima", "Maxima", "SymbolicComputation"]
thumbnailImagePosition: left
thumbnailImage: ./images/wxMaximaLogo.jpg
coverImage: ./FOTO.jpg
metaAlignment: center
disable_comments: true
output:
  blogdown::html_page:
    toc: false
    fig_width: 8
    css: "/css/my-style.css"
--- 


```{r include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, echo=FALSE, collapse = TRUE)
```

During my bachelor studies I had to derive enormous amount of derivatives, integrals and limits. Being a huge fan of open-source programms, I began to look for something similar to Maple. That is how I found   [wxMaxima](https://sourceforge.net/projects/wxmaxima/) an open-source, easy to install and use program. For many years I did not use it, but recently I had to derive some expressions of conditional moments for multivariate normal distribution. Noway I was doing this by hand and I rememmbered the long forgotten Maxima. I knew that one can do symbolic calculation in R with rSymPy and I even tried it, but it performed slow for my tasks, so I stayed with Maxima.  
In this post I will provide some instructions for Windows users. The first step is to download and install [wxMaxima](https://sourceforge.net/projects/wxmaxima/). 
I wrote a function, which feeds commands into Maxima, executes them, returns expressions, that can be evaluated in R, and allows the user to get tex expressions.

## Function
```{r echo=TRUE}
require(magrittr)

#' Execute lines in Maxima
#' @param obj - intermediate Maxima calculations
#' @param out - output from Maxima
#' @param pathm - path to maxima.bat
#' @param tex - include tex expressions
#' @return returns list, first element is a list of strings, that can be evaluated in R.
#'         second element - list of tex expression 
runMaxima <- function(obj, out, pathm = "C:\\maxima-5.38.1\\bin\\maxima", tex=TRUE){
  com <- c(paste0(obj, " ; "), paste0(out, " ; "))%>%paste0( collapse = "")
  # execute lines in maxima
  a <- shell(paste0('echo ', com , ' | "', pathm, '"'), intern=TRUE)
  ## form output blocks, they are separated by (%o
  #  start of block
  start <- c(1, grep("\\(%o",a) )%>%unique # output in Maxima begins with lines "(%o\\d)"
  #  end of block
  end <- start-1
  end <- c(end[-1],length(a))
  #  form output blocks
  aa <- lapply(1:length(start), function(i) a[start[i]:end[i]]) 
  ## search for tex output
  #  in Maxima tex output begins with $$ and ends with $$
  aa2 <- aa[sapply(aa, function(x) x%>%grepl("^\\$\\$|\\$\\$$", .)%>%any)]
  aa2 <- lapply(aa2, function(x)x%>%grep("false|done|new", ., value=TRUE, invert=TRUE)%>%paste0(., collapse = ""))
  #search the blocks that belong to output
  aa <- aa[sapply(aa, function(x) x%>%grepl("\\$$",.)%>%any)] #in Maxima the last output of line is given by $
  aa <- aa[sapply(aa, function(x)!(x%>%grepl("^\\$\\$|\\$\\$$", .)%>%any))] #remove tex blocks, they begin with $, remove $ and spaces
  aa <- lapply(aa, function(x)x%>%grep("done|new|false", ., invert=TRUE, value=TRUE)%>%paste0(., collapse = "")%>%gsub("(  )|\\$$","",.)) #remove some unnec. output
  names(aa) <- 1:length(aa)
  if (length(aa2)>0) names(aa2) <- 1:length(aa2)
  list(expr=aa, tex=aa2)
}
```

## Example

Suppose for some reason, one needs to get expressions of trivariate normal distribution.
First lets form variance-covariance matrix for usage in Maxima. R output:

```{r echo=TRUE}
library(magrittr)
```

Define number of random variables:

```{r echo=TRUE}
neq <- 3
```

## Maxima commands

Form symbolic variance-covariance matrix:

```{r echo=TRUE}
t1 <- neq%>%"^"(2)%>%rep("sigma", .)
t2 <- neq%>%rep(1:., .)
t3 <- t2%>%sort
t4 <- neq%>%"^"(2)%>%rep("rho[", .)
sigma <- paste0(t1, "[", t3 , "]*", t1,"[",t2 ,"]*", t4, t3,",", t2, "]" )
sigma <- matrix(sigma, neq, neq, byrow = TRUE) 
diag(sigma) %<>% gsub("\\*sigma\\[\\d{1,2}\\]\\*rho\\[\\d{1,2},\\d{1,2}\\]","**2", .)
sigma[lower.tri(sigma)] <- sort(sigma[upper.tri(sigma)])
```

```{r echo=FALSE}
library(knitr)
sigma%>%data.frame%>%kable
```

Maxima command for variance-covariance matrix:

```{r echo=TRUE}
spy <- paste0(sapply(1:neq, function(i) paste0("[", paste0("",sigma[i,],"", collapse = ", "), "]")), collapse = ",")
spy <- paste0("Sigma : matrix(", spy, ")")
```

Random variable vector:

```{r echo=TRUE}
ym <- 1:neq%>%paste0("[y[", .,"]]")%>%paste0(., collapse=", ")%>%paste0("y: matrix(", ., ")") # random variables
```

Vector of means:

```{r echo=TRUE}
mum <- 1:neq%>%paste0("[mu[", .,"]]")%>%paste0(., collapse=", ")%>%paste0("mu: matrix(", ., ")") # vector of means
```

Determinant of variance-covariance matrix, function ratsimp simplifies an expression:

```{r echo=TRUE}
detm <- "dets : ratsimp(determinant(Sigma))"
```

Inverse of variance-covariance matrix:

```{r echo=TRUE}
invm <- "invs : ratsimp(invert(Sigma))" 
```

Exponent in multivariate normal distribution:

```{r echo=TRUE}
expinside <- "inside: ratsimp(transpose(y-mu).invert(Sigma).(y-mu))"
```

Function for multivariate normal distribution:

```{r echo=TRUE}
MNf <- paste0("phi(x, mu, var):= 1/(sqrt((2*%pi)**",neq,"*ratsimp(determinant(var))))*%e**(-1/2*ratsimp(transpose(x-mu).invert(var).(x-mu)))")
```

Get symbolic expression of MN with vector y, mu and matrix Sigma:
```{r echo=TRUE}
expr <- "expt : phi(y, mu, Sigma)"
```

Vector with of strings that will be evaluated in Maxima:

```{r echo=TRUE}
obj <- c(ym, mum, spy, detm, invm, expinside, MNf, expr) 
```

Additional commands for Maxima to get evaluable expressions (grind function produces output which can be evaluated), print(new) is simply a place holder, :

```{r echo=TRUE}
out <- c('print(new)', 'grind(dets)',  'print(new)', 'grind(invs)', 'print(new)', 'grind(expt)', 'print(new)', 'grind(inside)') 
```

"''i(\\d)" takes object from the input supplied to Maxima and tex function produces tex output: 

```{r echo=TRUE}
ind <- c(4, 5, 6, 8)
out[ind]
out <- c(out, paste0("tex (''%i", ind,")")) 
```

Run Maxima:

```{r echo=TRUE}
res <- runMaxima(obj, out)
```


```{r echo=FALSE}
rinline <- function(code) {
  sprintf('``` `r %s` ```', code)
}

bracket_match<- function(s, i, indl, indr, .stro="(", .strc=")"){
  if(length(s)==1){
    s%<>%strsplit(., "*")%>%unlist
  }
  while ((i <= length(s))&(indl!=indr)){
    if (s[i] == .stro){
      indl <- indl+1
    }
    if (s[i] == .strc){
      indr <- indr +1
    }
    i = i+1
  }
  return(i-1)
}

#' @param str string where to look
#' @param .stro opening bracet to look for 
#' @param .strc closing bracet to look for
remove_double <- function(str, .stro="(", .strc=")"){
  if(length(str)==1){
    x <- str%>%strsplit(., "*")%>%unlist
  }else{
    x <- str
  }
  #x <- str%>%gsub(" ", "",.)%>%strsplit(., "*")%>%unlist
  #start of {
  inds <- which(x==.stro)
  #end of }
  inde <- sapply(inds, function(i)x%>%bracket_match(., i+1, 1, 0, .stro, .strc))
  j <- any((inds[-1]-inds[-length(inds)])==1)&any((inde[-1]-inde[-length(inde)])==-1)
  k <- 1
  while(j&k<length(inds)){
    #if {{..}} appears
    if((inds[k+1]-inds[k])==1&(inde[k+1]-inde[k])==-1){
      x <- x[-c(inds[k], inde[k])] 
      #start of {
      inds <- which(x==.stro)
      #end of }
      inde <- sapply(inds, function(i)x%>%bracket_match(., i+1, 1, 0,  .stro, .strc))
      j <- any((inds[-1]-inds[-length(inds)])==1)&any((inde[-1]-inde[-length(inde)])==-1)
    }
    k <- k + 1
  }
  x
}

remove_outer <- function(str, .stro="(", .strc=")", collapseS = NULL){
  if(length(str)==1){
    str %<>%strsplit(., "*")%>%unlist
  }
  #find first stro
  inds <- which(str==.stro)[1]
  inde <- bracket_match(str, inds+1, 1, 0, .stro, .strc)
  #distance from 1 to nchar is equal, thus outer bracets
  if(((inds-1)==(length(str)-inde))&(all((str[c(1:(inds-1), (inde+1):length(str))]%>%unique)%in%"$"))){
    str <- str[-c(inds+1, inde)]
  }
  str%>%paste0(., collapse=collapseS)
}

replace_over <- function(str, .stro="(", .strc=")", collapseS = NULL){
  if(length(str)==1){
    str %<>%strsplit(., "*")%>%unlist
  }
  x <- str%>%remove_double(., .stro, .strc)%>%remove_outer(., .stro, .strc) 
  #replace \over with frac
  inds <- which(x==.stro)
  #end of }
  inde <- sapply(inds, function(i)x%>%bracket_match(., i+1, 1, 0, .stro, .strc))
  xx <- x%>%paste0(., collapse="")
  st <- gregexpr("\\\\\\over", xx)[[1]]
  x[inds[which(inde%in%(st-1))]] <- "\\frac{"
  x%<>%paste0(., collapse="")%>%gsub("\\over","", ., fixed=TRUE)  
  x%<>%strsplit(., "*")%>%unlist
  x%>%paste0(., collapse = collapseS)
}

mod_string <- function(str, .stro="(", .strc=")", collapseS = NULL){
  x <- str%>%remove_double(., .stro, .strc)%>%remove_outer(., .stro, .strc)%>%replace_over(., .stro, .strc, collapseS = "")
  x
}
```

## Some tex output.


Determinant of $\Sigma$,  `r rinline("res$tex[[1]]")`:

```{r, results='asis', echo=FALSE}
res$tex[[1]]%>%mod_string(., .stro="{", .strc="}", collapseS = "")%>%cat(., "\n")

```


Inverse of  $\Sigma$,  `r rinline("res$tex[[2]]")`:asdasfef

```{r, results='asis', echo=FALSE}
res$tex[[2]]%>%mod_string(., .stro="{", .strc="}", collapseS = "")%>%cat(., "\n")
#res$tex[[2]]%>%strsplit(., "*")%>%unlist%>%bracket_match(., 12, 1, 0)
#if(res$tex[[2]]%>%grepl("^\\$\\$(\\-|)\\{\\{", .)&res$tex[[2]]%>%grepl("\\}\\}\\$\\$$", .)){
#     x <- res$tex[[2]]%>%gsub("^\\$\\$(\\-|)\\{\\{","$$\\1{",.)%>%gsub("\\}\\}\\$\\$$","}$$",.)
#}else{
#  x <- res$tex[[2]]
#}
#x%>%gsub("\\$\\$\\\\pmatrix\\{|\\}\\$\\$$","",.)%>%paste0("$$\\begin{bmatrix}", ., "\\end{bmatrix}$$")%>%cat(.,  "\n")
```


Exponent,  `r rinline("res$tex[[3]]")`:


```{r, results='asis', echo=FALSE}
res$tex[[3]]%>%mod_string(., .stro="{", .strc="}", collapseS = "")%>%cat(., "\n")
```

Density,  `r rinline("res$tex[[4]]")`:

```{r, results='asis', echo=FALSE}
res$tex[[4]]%>%mod_string(., .stro="{", .strc="}", collapseS = "")%>%cat(., "\n")
```

Testing simona.  

## Evaluate expression from Maxima in R:

```{r echo=TRUE}
expr <- res$expr[4]%>%paste0("1/(sqrt((2*pi)**",neq,"*",res$expr[1],"))*exp(-1/2*", ., ")")%>%gsub("\\[(\\d)\\]", "[[\\1]]",.)
yy <- replicate(neq, {rnorm(100, mean=4, sd=2)})
sigma <- apply(yy, 2, sd)
rho <- cor(yy)
y <- lapply(1:neq, function(x)yy[,x])
mu <- apply(yy, 2, mean)
r1 <- expr%>%parse(text=.)%>%eval
```

## Comparison with results from other functions and packages:

```{r echo=TRUE}
require(emdbook)
yy%>%dmvnorm(.,mu=mu,Sigma=cov(.))%>%"-"(r1)%>%abs%>%sum
```

```{r echo=TRUE}
require(mnormt)
yy%>%dmnorm(.,mean=mu,cov(.))%>%"-"(r1)%>%abs%>%sum
```